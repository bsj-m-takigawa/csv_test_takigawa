# Coding Guidelines（設計/コーディング原則・日本語）

本ドキュメントは、言語やフレームワークに依存しない共通の設計/コーディング原則を定義します。詳細は各プロジェクト/言語固有ガイドと併せて適用してください。

## 目的と範囲
- 変更を小さく安全に行い、保守性・可読性・再利用性を高める。
- バグを早期に検出/隔離し、影響範囲を限定する。
- 境界（I/O, API, DB, 環境）での健全性検証と、機密/安全要件の順守。

## 基本原則
- 単一責任（SRP）: モジュール/クラス/関数は1つの理由でのみ変更される。
- 高凝集・低結合: 関連するロジックは近くに、外部との接点は少なく明確に。
- KISS: 不要な複雑さを避け、直観的な実装を選ぶ。
- DRY: 知識の重複を避け、共通化する。ただし過度な抽象化は避ける。
- YAGNI: 使われていない拡張や設定は追加しない。
- Fail Fast: 不正な状態を早期に検出し、早めに失敗させる。
- 不変性の優先: 可能な限りデータ構造を不変にし、副作用を局所化。
- 依存の明示（DI）: 依存は引数やコンストラクタで渡し、隠れたグローバル依存を避ける。

## 設計と境界
- レイヤリング: プレゼン/アプリ/ドメイン/インフラを意識して役割を分離。
- API設計: 後方互換を優先。明確なスキーマ、バージョニング、エラー規約を定義。
- DTO/値オブジェクト: 境界入力を正規化し、内部では意味のある型で扱う。
- 入力検証: 境界で厳格に行い、内部では検証済みの型のみを流す。
- フィーチャーフラグ: 新機能や例外運用はフラグ/設定で段階的に導入。

## コード作法
- 関数: 小さく短く（目安20–40行）。早期returnでネストを浅く。
- 命名: 意図/単位/前提条件を名前に含める。略語や曖昧語を避ける。
- 構造: 公開API最小化、内部詳細のカプセル化。Mutableはスコープ最小。
- コメント: 「なぜ」を書く。コードから自明な「なに/how」は最小。

## 例外とエラー処理
- 分類: 復旧可能（再試行/フォールバック）と致命的（即時失敗）を分ける。
- 表現: ドメイン例外/アプリ例外/インフラ例外などに階層化。メッセージはユーザー向けと内部向けを分離。
- 制御: タイムアウト、リトライ、サーキットブレーカ等は明示的に。

## ログと可観測性
- レベル: `trace`/`debug`/`info`/`warn`/`error`/`fatal` の基準を遵守。
- 構造化: JSONやキー値で出力し、相関ID（`requestId`等）を付与。
- マスキング: 機密データは必ずマスク/トークナイズ。全量ダンプ禁止。
- メトリクス/トレース: 軽量な計測点を配置。しきい値とサンプリング率を設定。

## 型の安全性
- 境界でランタイム検証（API/CLI/ファイル/環境変数）。内部は正規化後の型を使用。
- 可能な限り狭い型を選び、ユニオン/リテラル/判別共用体等で表現。
- 例外/エラーは構造化して型で表し、分岐を安全に。

## テスト方針
- 境界のテストを優先（正常/境界/異常）。
- 単体テストでドメイン/ユーティリティを保護し、軽量統合テストで流れを確認。
- 回帰テストは最小再現を追加。テストデータは疑似化し、機密を含めない。

## パフォーマンス
- ボトルネックに集中。計測→仮説→改善→再計測のサイクル。
- アルゴリズム/データ構造の選択を優先し、マイクロ最適化は最後に。

## 適用上の注意（言語/規模/性能による調整指針）
- 原則の重み付け: 本ガイドは強力なデフォルト。常に最適とは限らないため、言語/規模/実行環境に応じて重み付けを調整する。
- 単一責任の粒度: 小規模や機能スライスでは縦に責務が併存する場合あり。将来の分割余地を残しつつ過剰分割を避ける。
- DRY vs 可読性: 早すぎる抽象化は避け、局所的な重複を許容する場面あり（重複の発見頻度と変更頻度で判断）。
- 不変性 vs 性能: ホットパスではコピー回避や構造的共有を検討。不変性は境界やテスト容易性の観点で確保。
- 例外モデルの選択: 例外/Result型/エラーコードのどれを用いるかはスタックに合わせ一貫化。境界での変換（例外→Resultなど）を明示。
- レイヤリング: 小規模サービスでの過剰な層分割は避け、必要最小の境界を維持。
- クライアント特有の制約: フロントエンドではログ量/PIIの制約が強い。サンプリングとマスキングを徹底。

### スタック別の上書きポイント（例）
- TypeScript/React:
  - `any`は原則回避し、`unknown`+型ガードを採用。判別共用体で状態をモデル化。
  - 境界入力（API/CSV/env）はランタイム検証を併用（既存のスキーマ/バリデータがある場合に限る）。
  - 副作用はHooksに局所化し、コンポーネントは責務と再利用単位で分割。
  - パフォーマンス要件が高い場合はメモ化/リスト仮想化等を計測と併せて適用。
- PHP/Laravel:
  - 入力はFormRequest/Validatorで検証し、DTO/値オブジェクトへ正規化してから処理。
  - ドメイン表現に`enum`/値オブジェクトを活用。Eloquentの副作用はサービス/リポジトリ層に寄せる。
  - 例外はアプリ層で集約し、HTTPレスポンス/ログとの責務を分離。

- 逸脱の記録: 原則から意図的に逸脱する場合は、理由/範囲/期限/ロールバック案をPRに簡潔に記述。

## コミット/PR
- 小さい差分、明確な目的。Conventional Commitsを推奨（例: `feat:`, `fix:`）。
- PRでは「動機/変更点/影響/検証」を簡潔に記載。スクリーンショット/パフォーマンス測定は必要に応じて。

## 言語/スタック別補足（簡易）
- TypeScript/React: `any`回避、`unknown`+型ガード、`readonly`、副作用はHooksに局所化、アクセシビリティ配慮。
- PHP/Laravel: 型宣言徹底、FormRequest/Validator、DTO/値オブジェクト、サービス/リポジトリで責務分離、例外ハンドラ集中。

---
運用詳細（ログ/マスキング/例外運用/難航時対応等）は `.codex/AGENTS.md` と整合させてください。
